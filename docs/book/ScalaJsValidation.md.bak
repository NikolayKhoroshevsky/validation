

Validation 2.0 supports Scala.js, which allows compiling validation logic for JavaScript to run it directly in the browser:

<textarea id="json-form" rows="10" cols="40">{
  "name" : "supercat",
  "age" : 20,
  "email" : "e@mail.com",
  "isAlive" : true
}</textarea><pre id="validation-output"></pre>
<script src="https://olivierblanvillain.github.io/play-scalajs-validation-example/assets/js-jsdeps.min.js" type="text/javascript"></script>
<script src="https://olivierblanvillain.github.io/play-scalajs-validation-example/assets/js-opt.js" type="text/javascript"></script>
<script src="https://olivierblanvillain.github.io/play-scalajs-validation-example/assets/js-launcher.js" type="text/javascript"></script>

<script type="text/javascript">
  var validationOutputPre = document.getElementById("validation-output")
  var jsonFormTextarea = document.getElementById("json-form")

  var demo = function() {
    try {
      var json = JSON.parse(jsonFormTextarea.value);
      validationOutputPre.innerHTML =
        JSON.stringify(client.Validate().user(json), null, 2);
    } catch(err) {
      validationOutputPre.innerHTML = err.message;
    }
  };

  jsonFormTextarea.addEventListener('input', demo, false);
  demo();
</script>

Using validation from Scala.js is no different than any other scala library. There is however some friction to intergration Scala.js into an existing Play + JavaScript, which we try to adress in this document. Assuming no prior knowledge on Scala.js, we explain how to cross compiled and integrate validation logic into an existing Play/JavaScript application.

You will first need to add two sbt plugins, Scala.js itself and `sbt-play-scalajs` to make it Scala.js and Play coexist nicely:

```scala
scala> cat("project/plugins.sbt")
addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.5.2")

addSbtPlugin("org.scala-js" % "sbt-scalajs" % "0.6.9")

addSbtPlugin("com.vmunier" % "sbt-play-scalajs" % "0.3.0")
```

Scala.js uses a separate compilation pass to transforms Scala sources in a single `.js` file. To indicate which part the Scala  codebase should be considered by Scala.js, you will need to use a separate sbt project. This is usually done with 3 projects, one targeting the JVM, another one targeting JS, and a third one for code shared between the two. In case of a Play application it could look like the following:

```
<project root>
 +- build.sbt
 +- jvm
 |   +- app
 |   +- conf
 |   +- public
 |   +- test
 +- js
 |   +- src/main/scala
 +- shared
     +- src/main/scala
```

Now let's look at a minimal `build.sbt` reflecting this structure. Information on the sbt settings are available on the [Scala.js documentation on cross build](https://www.scala-js.org/doc/project/cross-build.html), and on [`sbt-play-scalajs` documentation](https://github.com/vmunier/sbt-play-scalajs).

```scala
scala> cat("build.sbt")
val scalaV = "2.11.8"

lazy val jvm = project
  .in(file("jvm"))
  .settings(
    scalaVersion := scalaV,
    scalaJSProjects := Seq(js),
    pipelineStages := Seq(scalaJSProd),
    libraryDependencies ++= Seq(
      "com.vmunier" %% "play-scalajs-scripts" % "0.5.0",
      "io.github.jto" %% "validation-core" % "2.0",
      "io.github.jto" %% "validation-playjson" % "2.0"))
  .enablePlugins(PlayScala)
  .aggregate(js)
  .dependsOn(sharedJVM)

lazy val js = project
  .in(file("js"))
  .settings(
    scalaVersion := scalaV,
    persistLauncher := true,
    libraryDependencies ++= Seq(
      "io.github.jto" %%% "validation-core" % "2.0",
      "io.github.jto" %%% "validation-jsjson" % "2.0"))
  .enablePlugins(ScalaJSPlugin, ScalaJSPlay)
  .dependsOn(sharedJS)

lazy val shared = crossProject.crossType(CrossType.Pure)
  .in(file("shared"))
  .settings(scalaVersion := scalaV)
  .jsConfigure(_ enablePlugins ScalaJSPlay)

lazy val sharedJVM = shared.jvm
lazy val sharedJS = shared.js

onLoad in Global := (Command.process("project jvm", _: State)) compose (onLoad in Global).value
```

In addition to the `validation` dependency, we also included `play-scalajs-scripts`, which provides a convenient way to link the output of Scala.js compilation from a Play template:

```scala
scala> cat("jvm/app/views/main.scala.html")
@(title: String)(content: Html)(implicit environment: play.api.Environment)

<!DOCTYPE html>
<html>
  <head>
    <title>@title</title>
  </head>
  <body>
    @content
    @playscalajs.html.scripts(projectName = "js")
  </body>
</html>
```

Let's define a simple case class for our example, inside of the `shared` project to make it available to both JVM and JV platforms:

```scala
scala> cat("shared/src/main/scala/User.scala")
package model

case class User(
  name: String,
  age: Int,
  email: Option[String],
  isAlive: Boolean
)
```

In order to coexist with an existing JavaScript codebase, we have explicitly exposed some objects and methods to make then callable from JavaScript, which is done with the `@JSExport` annotation. This example exposes a single method taking a JavaScript object and returning a String representation of the validation output:

```scala
scala> cat("js/src/main/scala/Validate.scala")
package client

import jto.validation.{Rule, Valid, Invalid, VA}
import jto.validation.jsjson.{Rules, Writes}
import scala.scalajs.js
import js.annotation.JSExport
import model.User

@JSExport
object Validate {
  @JSExport
  def user(json: js.Dynamic): js.Dynamic = {
    import Rules._, Writes._

    val rule: Rule[js.Dynamic, User] = Rule.gen
    val validated: VA[User] = rule.validate(json)
    validated match {
      case e @ Invalid(_) => failureW.writes(e)
      case Valid(_) => json
    }
  }
}
```

As an example, we create a simple view with a textarea which validates it's content on every keystroke:

```scala
scala> cat("jvm/app/views/index.scala.html")
@(json: String)(implicit environment: play.api.Environment)

@main("Play Scala.js Validation") {
  <textarea id="json-form" rows="10" cols="40">@json</textarea>
  <div id="validation-output"></div>
}

<script type="text/javascript">
  var validationOutputDiv = document.getElementById("validation-output")
  var jsonFormTextarea = document.getElementById("json-form")

  var demo = function() {
    try {
      var json = JSON.parse(this.value);
      validationOutputDiv.innerHTML =
        JSON.stringify(client.Validate().user(json), null, 2);
    } catch(err) {
      validationOutputDiv.innerHTML = err.message;
    }
  };

  jsonFormTextarea.addEventListener('input', demo, false);
  jsonFormTextarea.dispatchEvent(new Event('input'));
</script>
```

This complete example is available in a [separate repository](https://github.com/OlivierBlanvillain/play-scalajs-validation-example). The example at the begining of this page was generated with Play in production mode, which fully optimizes the output of Scala.js compilation using the Google Closure Compiler, resulting a binary file under 100KB gzipped.
